<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Slowed + Reverb + 8D</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- JSZip Library for ZIP handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip-utils/0.1.0/jszip-utils.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 600px; /* Slightly wider for canvas */
            width: 100%;
            padding: 2rem;
            border: 1px solid #4a5568; /* Subtle border */
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #63b3ed; /* Blue thumb */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(99, 179, 237, 0.3);
            margin-top: -8px; /* Center thumb vertically */
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #63b3ed;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(99, 179, 237, 0.3);
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #4a5568; /* Darker track */
            border-radius: 3px;
        }
        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #4a5568;
            border-radius: 3px;
        }
        canvas {
            background-color: #1a202c; /* Dark background for canvas */
            border-radius: 0.75rem;
            border: 1px solid #4a5568;
        }

        /* Processing Overlay Styles */
        .processing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .processing-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .processing-card {
            background-color: #2d3748;
            border-radius: 1.5rem;
            padding: 2.5rem;
            text-align: center;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 400px;
            width: 90%;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #63b3ed;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1.5rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .step-indicator {
            display: flex;
            align-items: center;
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
            color: #a0aec0;
        }
        .step-indicator.active {
            color: #e2e8f0;
            font-weight: 600;
        }
        .step-number {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #4a5568;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-right: 0.75rem;
            font-weight: bold;
            color: #e2e8f0;
        }
        .step-indicator.active .step-number {
            background-color: #63b3ed;
        }

        /* Music Player Styles */
        .music-player {
            background-color: #1a202c; /* Darker background for player */
            border-radius: 1rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
            width: 100%;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .music-player.active {
            display: flex;
        }
        .progress-bar-container {
            width: 100%;
            height: 8px;
            background-color: #4a5568;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
        }
        .progress-bar {
            height: 100%;
            background-color: #63b3ed;
            border-radius: 4px;
            width: 0%;
        }
        .player-controls button {
            background: none;
            border: none;
            color: #e2e8f0;
            font-size: 1.8rem;
            cursor: pointer;
            transition: color 0.2s ease-in-out;
        }
        .player-controls button:hover {
            color: #63b3ed;
        }
        .volume-slider {
            width: 80px;
            height: 6px;
            background-color: #4a5568;
            border-radius: 3px;
            appearance: none;
            cursor: pointer;
        }
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #63b3ed;
            cursor: pointer;
            margin-top: -5px;
        }
        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #63b3ed;
            cursor: pointer;
        }

        /* Tab Navigation Styles */
        .tab-buttons {
            display: flex;
            justify-content: center;
            margin-bottom: 1.5rem;
            width: 100%;
        }
        .tab-button {
            padding: 0.75rem 1.5rem;
            background-color: #4a5568;
            color: #e2e8f0;
            border: none;
            border-radius: 0.75rem; /* Rounded corners for tabs */
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
            margin: 0 0.5rem; /* Spacing between buttons */
        }
        .tab-button.active {
            background-color: #63b3ed;
            color: #1a202c;
        }
        .tab-button:hover:not(.active) {
            background-color: #5a6478;
        }
        /* Batch Processing Status */
        .batch-status-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 1001;
            flex-direction: column;
            padding: 1rem;
        }
        .batch-status-card {
            background-color: #2d3748;
            border-radius: 1.5rem;
            padding: 2.5rem;
            text-align: center;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 500px;
            width: 90%;
        }
        .batch-progress-text {
            font-size: 1.2rem;
            color: #e2e8f0;
            margin-top: 1rem;
        }
        .batch-file-name {
            font-size: 1rem;
            color: #a0aec0;
            margin-top: 0.5rem;
            word-break: break-all; /* Ensure long file names wrap */
        }
    </style>
</head>
<body class="selection:bg-blue-500 selection:text-white">
    <div class="container flex flex-col items-center space-y-6" id="mainAppContainer">
        <h1 class="text-3xl font-bold text-blue-400 mb-4">Generador de Slowed + Reverb + 8D</h1>

        <!-- Tab Navigation -->
        <div class="tab-buttons">
            <button id="configTabButton" class="tab-button active">Configuraci√≥n</button>
            <button id="advancedTabButton" class="tab-button">Avanzado</button>
        </div>

        <!-- Configuration Section -->
        <div id="configSection" class="w-full flex flex-col items-center space-y-6">
            <!-- File Upload Section (Single Audio) -->
            <div class="w-full">
                <label for="audioFile" class="block text-lg font-medium text-gray-300 mb-2">Sube tu archivo de audio:</label>
                <input type="file" id="audioFile" accept="audio/*" class="w-full p-3 border border-gray-600 rounded-lg bg-gray-700 text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 cursor-pointer">
                <p id="fileName" class="text-sm text-gray-400 mt-2 text-center"></p>
            </div>

            <!-- Action Button for Single Audio -->
            <div class="w-full flex justify-center mt-6">
                <button id="processButton" class="px-8 py-4 bg-blue-600 text-white font-semibold rounded-full shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition-all duration-200 ease-in-out transform hover:scale-105" disabled>
                    Procesar Audio
                </button>
            </div>
        </div>

        <!-- Advanced Section -->
        <div id="advancedSection" class="w-full flex flex-col items-center space-y-6" style="display: none;">
            <p class="text-xl font-semibold text-gray-300 mb-4">Ajustes y Procesamiento por Lotes (ZIP)</p>
            <p class="text-gray-400 text-center mb-4">Configura los efectos y procesa m√∫ltiples archivos.</p>

            <!-- Controls for Speed, Reverb, 8D (Moved Here) -->
            <div class="w-full space-y-6">
                <!-- Speed Control -->
                <div>
                    <label for="speedRange" class="block text-lg font-medium text-gray-300 mb-2">Velocidad:</label>
                    <input type="range" id="speedRange" min="0.5" max="1.5" value="1.0" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <p class="text-center text-gray-400 mt-2">Valor: <span id="speedValue">1.00x</span></p>
                </div>

                <!-- Reverb Control -->
                <div>
                    <label for="reverbRange" class="block text-lg font-medium text-gray-300 mb-2">Reverberaci√≥n:</label>
                    <input type="range" id="reverbRange" min="0" max="1" value="0.3" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <p class="text-center text-gray-400 mt-2">Valor: <span id="reverbValue">0.30</span></p>
                </div>

                <!-- 8D Audio Toggle -->
                <div class="flex items-center justify-center space-x-3">
                    <input type="checkbox" id="8dAudioToggle" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500 cursor-pointer">
                    <label for="8dAudioToggle" class="text-lg font-medium text-gray-300">Activar Audio 8D</label>
                </div>
            </div>

            <div class="w-full border-t border-gray-600 pt-6 mt-6">
                <label for="zipFile" class="block text-lg font-medium text-gray-300 mb-2">Sube tu archivo .zip:</label>
                <input type="file" id="zipFile" accept=".zip" class="w-full p-3 border border-gray-600 rounded-lg bg-gray-700 text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 cursor-pointer">
                <p id="zipFileName" class="text-sm text-gray-400 mt-2 text-center"></p>
            </div>

            <div class="w-full flex justify-center mt-6">
                <button id="processZipButton" class="px-8 py-4 bg-purple-600 text-white font-semibold rounded-full shadow-lg hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75 transition-all duration-200 ease-in-out transform hover:scale-105" disabled>
                    Procesar ZIP
                </button>
            </div>

            <div id="batchResultSection" class="w-full flex flex-col items-center space-y-4 mt-8" style="display: none;">
                <p class="text-lg font-semibold text-green-400">¬°Procesamiento por lotes completado!</p>
                <button id="downloadZipButton" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-full shadow-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition-all duration-200 ease-in-out transform hover:scale-105">
                    Descargar ZIP Procesado
                </button>
                <p class="text-sm text-gray-400 text-center mt-2">Los archivos MP3 se han convertido a WAV dentro del ZIP.</p>
            </div>
        </div>

        <!-- Music Player Section -->
        <div class="music-player" id="musicPlayerSection">
            <p class="text-xl font-semibold text-gray-300 mb-4">¬°Disfruta tu canci√≥n terminada!</p>

            <!-- Circular Spectrum Visualizer -->
            <div class="w-full mb-6 flex justify-center items-center">
                <canvas id="circularSpectrumVisualizer" class="w-full h-32 max-w-xs"></canvas>
            </div>

            <!-- Time and Progress Bar -->
            <div class="w-full mb-4">
                <div class="flex justify-between text-sm text-gray-400 mb-1">
                    <span id="currentTime">00:00</span>
                    <span id="totalDuration">00:00</span>
                </div>
                <div class="progress-bar-container" id="progressBarContainer">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
            </div>

            <!-- Player Controls -->
            <div class="player-controls flex items-center justify-center space-x-6 mb-4">
                <button id="loopButton" title="Bucle">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-repeat"><path d="M17 1l4 4-4 4"/><path d="M3 11v-1a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v1a4 4 0 0 1-4 4H3"/></svg>
                </button>
                <button id="playPauseButton" title="Reproducir/Pausar">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                </button>
                <div class="flex items-center space-x-2">
                    <button id="volumeIcon" title="Volumen">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M22.39 2.61a15 15 0 0 1 0 18.78"/></svg>
                    </button>
                    <input type="range" id="volumeRange" min="0" max="1" value="1" step="0.01" class="volume-slider">
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="w-full flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 mt-4">
                <button id="downloadButton" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-full shadow-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition-all duration-200 ease-in-out transform hover:scale-105">
                    Descargar
                </button>
                <button id="startOverButton" class="px-6 py-3 bg-gray-600 text-white font-semibold rounded-full shadow-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-75 transition-all duration-200 ease-in-out transform hover:scale-105">
                    Empezar de Nuevo
                </button>
            </div>
        </div>

        <!-- Status and Messages -->
        <div id="messageBox" class="w-full p-4 mt-6 bg-yellow-800 text-yellow-200 rounded-lg hidden">
            <p id="messageText"></p>
        </div>
    </div>

    <!-- Processing Overlay (for single file) -->
    <div class="processing-overlay" id="processingOverlay">
        <div class="processing-card">
            <h2 class="text-2xl font-bold text-blue-400 mb-4">Slowed + Reverb Generator</h2>
            <p class="text-gray-300 mb-6">Esto puede tardar unos minutos</p>
            <div class="spinner"></div>
            <div class="space-y-3">
                <div class="step-indicator" id="step1">
                    <div class="step-number">1</div>
                    <span>Cargando Audio</span>
                </div>
                <div class="step-indicator" id="step2">
                    <div class="step-number">2</div>
                    <span>Reduciendo Velocidad</span>
                </div>
                <div class="step-indicator" id="step3">
                    <div class="step-number">3</div>
                    <span>A√±adiendo Reverberaci√≥n</span>
                </div>
            </div>
            <button id="cancelProcessingButton" class="mt-8 px-6 py-3 bg-pink-600 text-white font-semibold rounded-full shadow-lg hover:bg-pink-700 focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-opacity-75 transition-all duration-200 ease-in-out transform hover:scale-105">
                CANCELAR
            </button>
        </div>
    </div>

    <!-- Batch Processing Status Overlay -->
    <div class="batch-status-overlay" id="batchStatusOverlay">
        <div class="batch-status-card">
            <h2 class="text-2xl font-bold text-blue-400 mb-4">Procesando Lotes</h2>
            <div class="spinner"></div>
            <p class="batch-progress-text" id="batchProgressText">Iniciando procesamiento...</p>
            <p class="batch-file-name" id="batchCurrentFileName"></p>
            <button id="cancelBatchButton" class="mt-8 px-6 py-3 bg-pink-600 text-white font-semibold rounded-full shadow-lg hover:bg-pink-700 focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-opacity-75 transition-all duration-200 ease-in-out transform hover:scale-105">
                CANCELAR
            </button>
        </div>
    </div>


    <script>
        // Get DOM elements
        const configTabButton = document.getElementById('configTabButton');
        const advancedTabButton = document.getElementById('advancedTabButton');
        const configSection = document.getElementById('configSection');
        const advancedSection = document.getElementById('advancedSection');
        const musicPlayerSection = document.getElementById('musicPlayerSection');
        const audioFile = document.getElementById('audioFile');
        const fileNameSpan = document.getElementById('fileName');
        // Controls are now in advancedSection, but their values are read globally
        const speedRange = document.getElementById('speedRange');
        const speedValueSpan = document.getElementById('speedValue');
        const reverbRange = document.getElementById('reverbRange');
        const reverbValueSpan = document.getElementById('reverbValue');
        const d8AudioToggle = document.getElementById('8dAudioToggle');

        const processButton = document.getElementById('processButton'); // For single file
        const downloadButton = document.getElementById('downloadButton');
        const startOverButton = document.getElementById('startOverButton');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        
        // Visualizer Elements (circularSpectrumVisualizer)
        const circularSpectrumVisualizer = document.getElementById('circularSpectrumVisualizer');
        const canvasCtx = circularSpectrumVisualizer.getContext('2d');

        // Processing Overlay Elements (for single file)
        const processingOverlay = document.getElementById('processingOverlay');
        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const step3 = document.getElementById('step3');
        const cancelProcessingButton = document.getElementById('cancelProcessingButton');

        // Music Player Elements
        const currentTimeSpan = document.getElementById('currentTime');
        const totalDurationSpan = document.getElementById('totalDuration');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBar = document.getElementById('progressBar');
        const loopButton = document.getElementById('loopButton');
        const playPauseButton = document.getElementById('playPauseButton');
        const volumeIcon = document.getElementById('volumeIcon');
        const volumeRange = document.getElementById('volumeRange');
        const playIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play"><polygon points="5 3 19 12 5 21 5 3"/></svg>';
        const pauseIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pause"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>';
        const volumeHighIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M22.39 2.61a15 15 0 0 1 0 18.78"/></svg>';
        const volumeLowIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-1"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>';
        const volumeMuteIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-x"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="22" x2="16" y1="9" y2="15"/><line x1="16" x2="22" y1="9" y2="15"/></svg>';

        // Advanced Tab Elements (for ZIP processing)
        const zipFile = document.getElementById('zipFile');
        const zipFileNameSpan = document.getElementById('zipFileName');
        const processZipButton = document.getElementById('processZipButton');
        const batchResultSection = document.getElementById('batchResultSection');
        const downloadZipButton = document.getElementById('downloadZipButton');
        const batchStatusOverlay = document.getElementById('batchStatusOverlay');
        const batchProgressText = document.getElementById('batchProgressText');
        const batchCurrentFileName = document.getElementById('batchCurrentFileName');
        const cancelBatchButton = document.getElementById('cancelBatchButton');


        let audioContext;
        let originalBuffer = null; // For single file processing
        let processedBuffer = null; // For single file playback/download
        let currentSource = null; // To keep track of the currently playing source node
        let analyserNode = null;
        let gainNode = null; // For volume control
        let animationFrameId = null; // To control the visualizer animation loop
        let isPlaying = false;
        let isLooping = false;
        let startOffset = 0; // For seeking
        let startTime = 0; // To track when playback started for accurate current time calculation
        let processingAborted = false; // Flag to indicate if single file processing was cancelled
        let batchProcessingAborted = false; // Flag to indicate if batch processing was cancelled
        let finalProcessedZipBlob = null; // Stores the generated ZIP blob for download


        // --- UI State Management ---
        function showSection(sectionId) {
            configSection.style.display = 'none';
            advancedSection.style.display = 'none';
            musicPlayerSection.style.display = 'none';
            processingOverlay.style.display = 'none';
            processingOverlay.classList.remove('active');
            musicPlayerSection.classList.remove('active');
            batchStatusOverlay.style.display = 'none'; // Hide batch overlay by default

            // Deactivate all tab buttons
            configTabButton.classList.remove('active');
            advancedTabButton.classList.remove('active');

            if (sectionId === 'config') {
                configSection.style.display = 'flex';
                configTabButton.classList.add('active');
            } else if (sectionId === 'advanced') {
                advancedSection.style.display = 'flex';
                advancedTabButton.classList.add('active');
            } else if (sectionId === 'processing') { // Single file processing overlay
                processingOverlay.style.display = 'flex';
                processingOverlay.classList.add('active');
            } else if (sectionId === 'batch-processing') { // Batch processing overlay
                batchStatusOverlay.style.display = 'flex';
            } else if (sectionId === 'player') {
                musicPlayerSection.style.display = 'flex';
                musicPlayerSection.classList.add('active');
            }
        }

        function resetUI() {
            stopPlayback();
            originalBuffer = null;
            processedBuffer = null;
            fileNameSpan.textContent = '';
            zipFileNameSpan.textContent = ''; // Clear zip file name
            speedRange.value = 1.0;
            speedValueSpan.textContent = '1.00x';
            reverbRange.value = 0.3;
            reverbValueSpan.textContent = '0.30';
            d8AudioToggle.checked = false;
            processButton.disabled = true;
            processZipButton.disabled = true; // Disable zip button
            downloadButton.disabled = true;
            downloadZipButton.disabled = true; // Disable batch download button
            batchResultSection.style.display = 'none'; // Hide batch result section
            hideMessage();
            showSection('config'); // Go back to config section
            playPauseButton.innerHTML = playIcon;
            progressBar.style.width = '0%';
            currentTimeSpan.textContent = '00:00';
            totalDurationSpan.textContent = '00:00';
            loopButton.classList.remove('text-blue-400');
            volumeRange.value = 1;
            volumeIcon.innerHTML = volumeHighIcon;
            if (gainNode) gainNode.gain.value = 1;
            processingAborted = false; // Reset the flag
            batchProcessingAborted = false; // Reset batch flag
            finalProcessedZipBlob = null; // Clear the stored ZIP blob
            clearCanvas(); // Clear visualizer

            // Ensure correct button states on reset based on file selection
            if (audioFile.files.length > 0) {
                processButton.disabled = false;
            }
            if (zipFile.files.length > 0) {
                processZipButton.disabled = false;
            }
        }

        // --- Message Box Functions ---
        function showMessage(text, type = 'info') {
            messageText.textContent = text;
            messageBox.classList.remove('hidden', 'bg-red-800', 'bg-green-800', 'bg-yellow-800');
            if (type === 'error') {
                messageBox.classList.add('bg-red-800', 'text-red-200');
            } else if (type === 'success') {
                messageBox.classList.add('bg-green-800', 'text-green-200');
            } else {
                messageBox.classList.add('bg-yellow-800', 'text-yellow-200');
            }
        }

        function hideMessage() {
            messageBox.classList.add('hidden');
        }

        // --- Audio Context & Nodes Initialization ---
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyserNode = audioContext.createAnalyser();
                analyserNode.fftSize = 256; // Smaller FFT size for more responsive circular visualizer
                gainNode = audioContext.createGain(); // Master gain for volume control
                gainNode.connect(analyserNode); // Connect gain to analyser
                analyserNode.connect(audioContext.destination); // Connect analyser to speakers
            }
        }

        // --- File Handling (Single Audio File) ---
        audioFile.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                fileNameSpan.textContent = `Archivo cargado: ${file.name}`;
                showMessage('Cargando audio...', 'info');
                processButton.disabled = true;
                stopPlayback(); // Stop any ongoing playback

                initAudioContext();

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        originalBuffer = await audioContext.decodeAudioData(e.target.result);
                        showMessage('Audio cargado con √©xito. Ajusta los par√°metros en "Avanzado" y procesa.', 'success');
                        processButton.disabled = false;
                    } catch (error) {
                        console.error('Error al decodificar el audio:', error);
                        showMessage('Error al cargar el audio. Aseg√∫rate de que es un archivo de audio v√°lido.', 'error');
                        originalBuffer = null;
                        fileNameSpan.textContent = '';
                    }
                };
                reader.onerror = () => {
                    showMessage('Error al leer el archivo.', 'error');
                    originalBuffer = null;
                    fileNameSpan.textContent = '';
                };
                reader.readAsArrayBuffer(file);
            } else {
                // If no file is selected, clear the file name and disable the process button
                fileNameSpan.textContent = '';
                originalBuffer = null;
                processButton.disabled = true;
                hideMessage();
            }
        });

        // --- File Handling (ZIP File) ---
        zipFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                zipFileNameSpan.textContent = `Archivo ZIP cargado: ${file.name}`;
                processZipButton.disabled = false;
                batchResultSection.style.display = 'none'; // Hide previous batch result
                downloadZipButton.disabled = true;
                showMessage('Archivo ZIP listo para procesar.', 'info');
            } else {
                zipFileNameSpan.textContent = '';
                processZipButton.disabled = true;
                batchResultSection.style.display = 'none';
                downloadZipButton.disabled = true;
                hideMessage();
            }
        });

        // --- Slider Value Display ---
        speedRange.addEventListener('input', () => {
            speedValueSpan.textContent = parseFloat(speedRange.value).toFixed(2) + 'x';
        });

        reverbRange.addEventListener('input', () => {
            reverbValueSpan.textContent = parseFloat(reverbRange.value).toFixed(2);
        });

        // --- Playback Control ---
        function stopPlayback() {
            if (currentSource) {
                currentSource.stop();
                currentSource.disconnect();
                currentSource = null;
            }
            isPlaying = false;
            playPauseButton.innerHTML = playIcon;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                clearCanvas();
            }
            startOffset = 0; // Reset offset when stopping completely
            startTime = 0; // Reset start time
            progressBar.style.width = '0%';
            currentTimeSpan.textContent = '00:00';
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes < 10 ? '0' : ''}${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        }

        // --- Circular Spectrum Visualizer ---
        function clearCanvas() {
            canvasCtx.clearRect(0, 0, circularSpectrumVisualizer.width, circularSpectrumVisualizer.height);
        }

        function drawVisualizer() {
            animationFrameId = requestAnimationFrame(drawVisualizer);

            const bufferLength = analyserNode.frequencyBinCount; // Number of frequency bins
            const dataArray = new Uint8Array(bufferLength); // For frequency domain data
            analyserNode.getByteFrequencyData(dataArray); // Get frequency data

            const WIDTH = circularSpectrumVisualizer.width;
            const HEIGHT = circularSpectrumVisualizer.height;
            const centerX = WIDTH / 2;
            const centerY = HEIGHT / 2;
            const radius = Math.min(WIDTH, HEIGHT) / 4; // Base radius of the circle

            canvasCtx.clearRect(0, 0, WIDTH, HEIGHT); // Clear the canvas

            // Draw a central circle to make it look cleaner
            canvasCtx.beginPath();
            canvasCtx.arc(centerX, centerY, radius * 0.8, 0, 2 * Math.PI);
            canvasCtx.fillStyle = '#1a202c'; // Inner circle color
            canvasCtx.fill();
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#4a5568'; // Border color
            canvasCtx.stroke();


            const barWidth = 360 / bufferLength; // Degrees per bar
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i] * 0.7; // Scale frequency data to height

                // Calculate angle for the bar
                const angle = (i * barWidth) * Math.PI / 180; // Convert to radians

                // Calculate start and end points of the bar
                const x1 = centerX + radius * Math.cos(angle);
                const y1 = centerY + radius * Math.sin(angle);
                const x2 = centerX + (radius + barHeight) * Math.cos(angle);
                const y2 = centerY + (radius + barHeight) * Math.sin(angle);

                // Draw the bar
                canvasCtx.beginPath();
                canvasCtx.moveTo(x1, y1);
                canvasCtx.lineTo(x2, y2);
                canvasCtx.strokeStyle = `hsl(${i / bufferLength * 360}, 100%, 50%)`; // Color based on frequency
                canvasCtx.lineWidth = 2;
                canvasCtx.stroke();
            }
        }


        // --- Single File Processing Logic ---
        processButton.addEventListener('click', async () => {
            if (!originalBuffer) {
                showMessage('Por favor, sube un archivo de audio primero.', 'error');
                return;
            }

            hideMessage();
            showSection('processing'); // Show processing overlay
            step1.classList.add('active');
            step2.classList.remove('active');
            step3.classList.remove('active');
            processedBuffer = null; // Clear previous processed buffer
            processingAborted = false; // Reset the flag

            // Get settings from Advanced tab
            const speed = parseFloat(speedRange.value);
            const reverbAmount = parseFloat(reverbRange.value);
            const enable8D = d8AudioToggle.checked;

            // Stop any current playback
            stopPlayback();

            // --- Offline Rendering for Download and Playback ---
            const reverbTailDuration = reverbAmount * 2; // Max 2 seconds for full reverb
            const offlineContextDuration = originalBuffer.length / originalBuffer.sampleRate / speed + reverbTailDuration;

            const offlineContext = new OfflineAudioContext(
                originalBuffer.numberOfChannels,
                offlineContextDuration * originalBuffer.sampleRate, // Total frames
                originalBuffer.sampleRate
            );

            const offlineSource = offlineContext.createBufferSource();
            offlineSource.buffer = originalBuffer;
            offlineSource.playbackRate.value = speed;

            let offlineLastNode = offlineSource;

            // Simulate step 2: Slowing It Down
            setTimeout(() => {
                if (processingAborted) return;
                step2.classList.add('active');
            }, 1000); // Small delay for visual effect

            // Offline Reverb
            if (reverbAmount > 0) {
                const offlineDryGain = offlineContext.createGain();
                offlineDryGain.gain.value = 1 - reverbAmount;

                const offlineWetGain = offlineContext.createGain();
                offlineWetGain.gain.value = reverbAmount;

                const numDelays = 5;
                const delayTime = 0.05;
                const decayRate = 0.6;

                let offlineCurrentDelayNode = offlineSource;
                for (let i = 0; i < numDelays; i++) {
                    const delay = offlineContext.createDelay(delayTime * numDelays);
                    delay.delayTime.value = delayTime * (i + 1);
                    const gain = offlineContext.createGain();
                    gain.gain.value = Math.pow(decayRate, i + 1);
                    offlineCurrentDelayNode.connect(delay);
                    delay.connect(gain);
                    gain.connect(offlineWetGain);
                    offlineCurrentDelayNode = gain;
                }

                offlineSource.connect(offlineDryGain);
                const offlineMerger = offlineContext.createChannelMerger(2);
                offlineDryGain.connect(offlineMerger, 0, 0);
                offlineWetGain.connect(offlineMerger, 0, 1);
                offlineLastNode = offlineMerger;
            }

            // Simulate step 3: Adding Reverb
            setTimeout(() => {
                if (processingAborted) return;
                step3.classList.add('active');
            }, 2000); // Small delay for visual effect

            // Offline 8D Audio - Optimized Panner Scheduling
            if (enable8D) {
                const offlinePanner = offlineContext.createPanner();
                offlinePanner.panningModel = 'HRTF';
                offlinePanner.distanceModel = 'linear';
                offlinePanner.coneOuterGain = 0.1;
                offlinePanner.coneOuterAngle = 180;
                offlinePanner.coneInnerAngle = 0;
                offlinePanner.refDistance = 1;
                offlinePanner.maxDistance = 10000;
                offlinePanner.rolloffFactor = 1;

                offlineLastNode.connect(offlinePanner);
                offlineLastNode = offlinePanner;

                const pannerFrequency = 0.05; // How fast it moves (lower = slower)
                const pannerRange = 5; // How far left/right it moves
                const pannerStepInterval = 0.1; // Update panner position every 0.1 seconds

                // Set initial position
                offlinePanner.positionX.setValueAtTime(0, 0);

                // Schedule panner position changes
                for (let i = pannerStepInterval; i <= offlineContextDuration; i += pannerStepInterval) {
                    const x = Math.sin(i * pannerFrequency) * pannerRange;
                    offlinePanner.positionX.linearRampToValueAtTime(x, i);
                }
                // Ensure the last value is set at the very end of the duration
                const finalX = Math.sin(offlineContextDuration * pannerFrequency) * pannerRange;
                offlinePanner.positionX.linearRampToValueAtTime(finalX, offlineContextDuration);
            }

            offlineLastNode.connect(offlineContext.destination);
            offlineSource.start(0);

            try {
                const renderStartTime = performance.now(); // Measure rendering time
                processedBuffer = await offlineContext.startRendering();
                const renderEndTime = performance.now();
                console.log(`Offline rendering took: ${(renderEndTime - renderStartTime).toFixed(2)} ms`);

                if (processingAborted) { // Check if cancelled during rendering
                    console.log("Processing was aborted by user.");
                    return; // Exit without showing player
                }

                showSection('player'); // Show player after processing
                downloadButton.disabled = false;
                totalDurationSpan.textContent = formatTime(processedBuffer.duration);
                playProcessedAudio(); // Auto-play
                showMessage('¬°Audio procesado con √©xito! Reproduciendo...', 'success');
            } catch (error) {
                console.error('Error al renderizar el audio offline:', error);
                if (!processingAborted) { // Only show error if not manually cancelled
                    showMessage('Error al preparar el audio para descargar o reproducir. Intenta con otro archivo.', 'error');
                } else {
                    showMessage('Procesamiento cancelado.', 'info');
                }
                processedBuffer = null;
                downloadButton.disabled = true;
                resetUI(); // Go back to initial state on error or cancel
            } finally {
                processingOverlay.classList.remove('active'); // Hide processing overlay
                processingOverlay.style.display = 'none';
            }
        });

        // --- Play Processed Audio (for single file) ---
        function playProcessedAudio() {
            stopPlayback(); // Ensure no other audio is playing

            if (!processedBuffer) {
                showMessage('No hay audio procesado para reproducir.', 'error');
                return;
            }

            currentSource = audioContext.createBufferSource();
            currentSource.buffer = processedBuffer;
            currentSource.connect(gainNode); // Connect to master gain for volume control

            currentSource.loop = isLooping; // Set loop property

            startTime = audioContext.currentTime; // Record start time
            currentSource.start(0, startOffset); // Start from current offset

            isPlaying = true;
            playPauseButton.innerHTML = pauseIcon;
            drawVisualizer(); // Start visualizer

            // Update progress bar and current time
            const updatePlaybackState = () => {
                if (isPlaying && currentSource) {
                    const elapsed = audioContext.currentTime - startTime + startOffset;
                    const progress = (elapsed / processedBuffer.duration) * 100;
                    progressBar.style.width = `${progress}%`;
                    currentTimeSpan.textContent = formatTime(elapsed);

                    if (elapsed < processedBuffer.duration) {
                        animationFrameId = requestAnimationFrame(updatePlaybackState);
                    } else if (!isLooping) {
                        stopPlayback(); // Stop if not looping and finished
                        showMessage('Reproducci√≥n finalizada.', 'info');
                    }
                }
            };
            animationFrameId = requestAnimationFrame(updatePlaybackState); // Start the update loop

            currentSource.onended = () => {
                if (!isLooping) {
                    stopPlayback();
                    showMessage('Reproducci√≥n finalizada.', 'info');
                }
                // If looping, the source will automatically restart, so no need to stop here.
            };
        }

        // --- Batch Processing Logic (ZIP File) ---
        processZipButton.addEventListener('click', async () => {
            const file = zipFile.files[0];
            if (!file) {
                showMessage('Por favor, sube un archivo .zip primero.', 'error');
                return;
            }

            hideMessage();
            showSection('batch-processing'); // Show batch processing overlay
            batchProgressText.textContent = 'Cargando ZIP...';
            batchCurrentFileName.textContent = '';
            batchProcessingAborted = false;
            finalProcessedZipBlob = null; // Clear previous ZIP blob

            // Get settings from Advanced tab
            const speed = parseFloat(speedRange.value);
            const reverbAmount = parseFloat(reverbRange.value);
            const enable8D = d8AudioToggle.checked;

            let zip;
            try {
                zip = await JSZip.loadAsync(file);
            } catch (error) {
                console.error('Error al cargar el archivo ZIP:', error);
                showMessage('Error al cargar el archivo ZIP. Aseg√∫rate de que es un archivo ZIP v√°lido.', 'error');
                showSection('advanced'); // Go back to advanced tab
                return;
            }

            const mp3Files = [];
            zip.forEach((relativePath, zipEntry) => {
                // Only process .mp3 files and ignore directories
                if (!zipEntry.dir && relativePath.toLowerCase().endsWith('.mp3')) {
                    mp3Files.push(zipEntry);
                }
            });

            if (mp3Files.length === 0) {
                showMessage('El archivo ZIP no contiene archivos MP3.', 'info');
                showSection('advanced');
                return;
            }

            const outputZip = new JSZip();
            let processedCount = 0;

            for (const mp3Entry of mp3Files) {
                if (batchProcessingAborted) {
                    showMessage('Procesamiento por lotes cancelado.', 'info');
                    break;
                }

                batchProgressText.textContent = `Procesando archivo ${processedCount + 1} de ${mp3Files.length}:`;
                batchCurrentFileName.textContent = mp3Entry.name;

                try {
                    const arrayBuffer = await mp3Entry.async('arraybuffer');
                    initAudioContext(); // Ensure context is initialized

                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                    // --- Apply effects using OfflineAudioContext for each file ---
                    const reverbTailDuration = reverbAmount * 2;
                    const offlineContextDuration = audioBuffer.length / audioBuffer.sampleRate / speed + reverbTailDuration;

                    const offlineContext = new OfflineAudioContext(
                        audioBuffer.numberOfChannels,
                        offlineContextDuration * audioBuffer.sampleRate,
                        audioBuffer.sampleRate
                    );

                    const offlineSource = offlineContext.createBufferSource();
                    offlineSource.buffer = audioBuffer;
                    offlineSource.playbackRate.value = speed;

                    let offlineLastNode = offlineSource;

                    // Offline Reverb
                    if (reverbAmount > 0) {
                        const offlineDryGain = offlineContext.createGain();
                        offlineDryGain.gain.value = 1 - reverbAmount;
                        const offlineWetGain = offlineContext.createGain();
                        offlineWetGain.gain.value = reverbAmount;
                        const numDelays = 5;
                        const delayTime = 0.05;
                        const decayRate = 0.6;
                        let offlineCurrentDelayNode = offlineSource;
                        for (let i = 0; i < numDelays; i++) {
                            const delay = offlineContext.createDelay(delayTime * numDelays);
                            delay.delayTime.value = delayTime * (i + 1);
                            const gain = offlineContext.createGain();
                            gain.gain.value = Math.pow(decayRate, i + 1);
                            offlineCurrentDelayNode.connect(delay);
                            delay.connect(gain);
                            gain.connect(offlineWetGain);
                            offlineCurrentDelayNode = gain;
                        }
                        offlineSource.connect(offlineDryGain);
                        const offlineMerger = offlineContext.createChannelMerger(2);
                        offlineDryGain.connect(offlineMerger, 0, 0);
                        offlineWetGain.connect(offlineMerger, 0, 1);
                        offlineLastNode = offlineMerger;
                    }

                    // Offline 8D Audio
                    if (enable8D) {
                        const offlinePanner = offlineContext.createPanner();
                        offlinePanner.panningModel = 'HRTF';
                        offlinePanner.distanceModel = 'linear';
                        offlinePanner.coneOuterGain = 0.1;
                        offlinePanner.coneOuterAngle = 180;
                        offlinePanner.coneInnerAngle = 0;
                        offlinePanner.refDistance = 1;
                        offlinePanner.maxDistance = 10000;
                        offlinePanner.rolloffFactor = 1;
                        offlineLastNode.connect(offlinePanner);
                        offlineLastNode = offlinePanner;
                        const pannerFrequency = 0.05;
                        const pannerRange = 5;
                        const pannerStepInterval = 0.1;
                        offlinePanner.positionX.setValueAtTime(0, 0);
                        for (let i = pannerStepInterval; i <= offlineContextDuration; i += pannerStepInterval) {
                            const x = Math.sin(i * pannerFrequency) * pannerRange;
                            offlinePanner.positionX.linearRampToValueAtTime(x, i);
                        }
                        const finalX = Math.sin(offlineContextDuration * pannerFrequency) * pannerRange;
                        offlinePanner.positionX.linearRampToValueAtTime(finalX, offlineContextDuration);
                    }

                    offlineLastNode.connect(offlineContext.destination);
                    offlineSource.start(0);

                    const processedAudioBuffer = await offlineContext.startRendering();
                    const wavData = encodeWAV(processedAudioBuffer); // Encode to WAV
                    const newFileName = mp3Entry.name.replace(/\.mp3$/i, '_processed.wav'); // Change extension
                    outputZip.file(newFileName, wavData);
                    processedCount++;

                } catch (innerError) {
                    console.error(`Error processing ${mp3Entry.name}:`, innerError);
                    // Continue to next file even if one fails
                }
            }

            batchStatusOverlay.style.display = 'none'; // Hide batch status overlay

            if (batchProcessingAborted) {
                showMessage('Procesamiento por lotes cancelado.', 'info');
                showSection('advanced');
                return;
            }

            if (processedCount > 0) {
                showMessage('Generando archivo ZIP para descarga...', 'info');
                try {
                    // Generate the final ZIP blob
                    finalProcessedZipBlob = await outputZip.generateAsync({ type: 'blob' });
                    downloadZipButton.disabled = false;
                    batchResultSection.style.display = 'flex'; // Show download button
                    showMessage(`¬°Procesamiento por lotes completado! ${processedCount} archivos procesados.`, 'success');
                } catch (error) {
                    console.error('Error al generar el ZIP final:', error);
                    showMessage('Error al generar el archivo ZIP para descarga.', 'error');
                    showSection('advanced');
                }
            } else {
                showMessage('No se pudieron procesar archivos MP3 v√°lidos.', 'error');
                showSection('advanced');
            }
        });

        // --- Music Player Controls (for single file) ---
        playPauseButton.addEventListener('click', () => {
            if (!processedBuffer) {
                showMessage('Por favor, procesa un audio primero para reproducir.', 'error');
                return;
            }

            if (isPlaying) {
                // Pause
                stopPlayback();
                startOffset = audioContext.currentTime - startTime + startOffset; // Save current position
                playPauseButton.innerHTML = playIcon;
            } else {
                // Play
                playProcessedAudio();
                playPauseButton.innerHTML = pauseIcon;
            }
        });

        loopButton.addEventListener('click', () => {
            isLooping = !isLooping;
            loopButton.classList.toggle('text-blue-400', isLooping); // Highlight if active
            if (currentSource) {
                currentSource.loop = isLooping;
            }
            showMessage(isLooping ? 'Bucle activado.' : 'Bucle desactivado.', 'info');
        });

        volumeRange.addEventListener('input', () => {
            if (gainNode) {
                gainNode.gain.value = parseFloat(volumeRange.value);
                if (volumeRange.value == 0) {
                    volumeIcon.innerHTML = volumeMuteIcon;
                } else if (volumeRange.value < 0.5) {
                    volumeIcon.innerHTML = volumeLowIcon;
                } else {
                    volumeIcon.innerHTML = volumeHighIcon;
                }
            }
        });

        progressBarContainer.addEventListener('click', (e) => {
            if (!processedBuffer) return;

            const clickX = e.clientX - progressBarContainer.getBoundingClientRect().left;
            const percentage = clickX / progressBarContainer.offsetWidth;
            const seekTime = percentage * processedBuffer.duration;

            stopPlayback(); // Stop current playback
            startOffset = seekTime; // Set new start offset
            playProcessedAudio(); // Play from new offset
        });

        // --- Download and Start Over Buttons ---
        downloadButton.addEventListener('click', () => {
            if (!processedBuffer) {
                showMessage('No hay audio procesado para descargar. Por favor, procesa el audio primero.', 'error');
                return;
            }

            stopPlayback(); // Stop any ongoing playback before download

            showMessage('Preparando descarga...', 'info');

            const wavData = encodeWAV(processedBuffer);
            const blob = new Blob([wavData], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);

            // Using window.open for better compatibility in AppCreator24 webviews
            window.open(url, '_blank');
            
            // Give user a hint if download doesn't start automatically
            showMessage('La descarga deber√≠a comenzar en una nueva pesta√±a/ventana. Si no, revisa tu gestor de descargas.', 'success');
            // Revoke object URL after a short delay to allow download to initiate
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        });

        // Download ZIP Button (for batch processing) - MODIFIED FOR APPCREATOR24 COMPATIBILITY
        downloadZipButton.addEventListener('click', () => {
            if (!finalProcessedZipBlob) {
                showMessage('No hay un archivo ZIP procesado para descargar.', 'error');
                return;
            }

            showMessage('Iniciando descarga del ZIP...', 'info');
            const zipUrl = URL.createObjectURL(finalProcessedZipBlob);
            
            // Attempt to open in a new window/tab for better AppCreator24 compatibility
            window.open(zipUrl, '_blank');

            // Provide user feedback
            showMessage('La descarga del ZIP deber√≠a comenzar en una nueva pesta√±a/ventana. Si no, revisa tu gestor de descargas.', 'success');
            
            // Revoke object URL after a short delay to allow download to initiate
            setTimeout(() => URL.revokeObjectURL(zipUrl), 1000);
        });


        startOverButton.addEventListener('click', () => {
            resetUI();
            showMessage('Aplicaci√≥n reiniciada. Sube un nuevo archivo.', 'info');
        });

        cancelProcessingButton.addEventListener('click', () => {
            processingAborted = true; // Set flag to abort processing
            showMessage('Cancelando procesamiento...', 'info');
        });

        cancelBatchButton.addEventListener('click', () => {
            batchProcessingAborted = true; // Set flag to abort batch processing
            showMessage('Cancelando procesamiento por lotes...', 'info');
        });


        // Helper function to encode AudioBuffer to WAV format
        function encodeWAV(audioBuffer) {
            const numChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const format = 1; // PCM (uncompressed)
            const bitDepth = 16; // 16-bit samples

            let interleaved = [];
            for (let i = 0; i < audioBuffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    interleaved.push(audioBuffer.getChannelData(channel)[i]);
                }
            }

            const buffer = new ArrayBuffer(44 + interleaved.length * 2);
            const view = new DataView(buffer);

            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + interleaved.length * 2, true); // ChunkSize
            writeString(view, 8, 'WAVE');

            // FMT sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)
            view.setUint16(20, format, true); // AudioFormat (1 for PCM)
            view.setUint16(22, numChannels, true); // NumChannels
            view.setUint32(24, sampleRate, true); // SampleRate
            view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true); // ByteRate
            view.setUint16(32, numChannels * (bitDepth / 8), true); // BlockAlign
            view.setUint16(34, bitDepth, true); // BitsPerSample

            // DATA sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, interleaved.length * 2, true); // Subchunk2Size

            // Write the PCM data
            let offset = 44;
            for (let i = 0; i < interleaved.length; i++, offset += 2) {
                let s = Math.max(-1, Math.min(1, interleaved[i])); // Clamp to -1 to 1
                s = s < 0 ? s * 0x8000 : s * 0x7FFF; // Convert to 16-bit integer
                view.setInt16(offset, s, true);
            }

            return buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // --- Initial Setup ---
        // Ensure AudioContext is resumed on first user gesture
        document.body.addEventListener('click', () => {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }, { once: true });

        // Adjust canvas size to be responsive
        function resizeCanvas() {
            // Set canvas dimensions to be square and fill available width up to max-w-xs
            const size = Math.min(circularSpectrumVisualizer.parentElement.offsetWidth, 200); // max-w-xs is 20rem = 320px, but h-32 is 128px, so limit by height
            circularSpectrumVisualizer.width = size;
            circularSpectrumVisualizer.height = size;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initial call

        // Tab button event listeners
        configTabButton.addEventListener('click', () => showSection('config'));
        advancedTabButton.addEventListener('click', () => showSection('advanced'));

        resetUI(); // Set initial UI state
    </script>
</body>
</html>

Math.sin(finalAngle) * pannerRadius, offlineContextDuration);
                        offlinePanner.positionZ.linearRampToValueAtTime(Math.cos(finalAngle) * pannerRadius, offlineContextDuration);
                        offlinePanner.positionY.linearRampToValueAtTime(Math.sin(finalAngle * 0.9) * pannerHeightOscillation, offlineContextDuration);
                    }

                    offlineLastNode.connect(offlineContext.destination);
                    offlineSource.start(0);

                    const processedAudioBuffer = await offlineContext.startRendering();
                    const wavData = encodeWAV(processedAudioBuffer); // Encode to WAV
                    const newFileName = mp3Entry.name.replace(/\.mp3$/i, '_processed.wav'); // Change extension
                    outputZip.file(newFileName, wavData);
                    processedCount++;

                } catch (innerError) {
                    console.error(`Error processing ${mp3Entry.name}:`, innerError);
                    // Continue to next file even if one fails
                }
            }

            batchStatusOverlay.style.display = 'none'; // Hide batch status overlay

            if (batchProcessingAborted) {
                showMessage('Procesamiento por lotes cancelado.', 'info');
                showSection('advanced');
                return;
            }

            if (processedCount > 0) {
                showMessage('Generando archivo ZIP para descarga...', 'info');
                try {
                    // Generate the final ZIP blob
                    finalProcessedZipBlob = await outputZip.generateAsync({ type: 'blob' });
                    downloadZipButton.disabled = false;
                    batchResultSection.style.display = 'flex'; // Show download button
                    showMessage(`¬°Procesamiento por lotes completado! ${processedCount} archivos procesados.`, 'success');
                } catch (error) {
                    console.error('Error al generar el ZIP final:', error);
                    showMessage('Error al generar el archivo ZIP para descarga.', 'error');
                    showSection('advanced');
                }
            } else {
                showMessage('No se pudieron procesar archivos MP3 v√°lidos.', 'error');
                showSection('advanced');
            }
        });

        // --- Music Player Controls (for single file) ---
        playPauseButton.addEventListener('click', () => {
            if (!processedBuffer) {
                showMessage('Por favor, procesa un audio primero para reproducir.', 'error');
                return;
            }

            if (isPlaying) {
                // Pause
                startOffset = audioContext.currentTime - startTime + startOffset; // Save current position
                stopPlayback(); // This will set isPlaying to false, clear animation, but preserve startOffset
            } else {
                // Play
                playProcessedAudio(); // This will start from startOffset
            }
        });

        loopButton.addEventListener('click', () => {
            isLooping = !isLooping;
            loopButton.classList.toggle('text-blue-400', isLooping); // Highlight if active
            if (currentSource) {
                currentSource.loop = isLooping;
            }
            showMessage(isLooping ? 'Bucle activado.' : 'Bucle desactivado.', 'info');
        });

        rewindButton.addEventListener('click', () => {
            if (!processedBuffer) {
                showMessage('No hay audio para retroceder.', 'error');
                return;
            }
            const currentPlaybackTime = audioContext.currentTime - startTime + startOffset;
            const newSeekTime = Math.max(0, currentPlaybackTime - 10); // Don't go below 0
            startOffset = newSeekTime; // Update startOffset
            playProcessedAudio(); // This will stop current and start new from new startOffset
            showMessage(`Retrocediendo a ${formatTime(newSeekTime)}`, 'info');
        });

        forwardButton.addEventListener('click', () => {
            if (!processedBuffer) {
                showMessage('No hay audio para avanzar.', 'error');
                return;
            }
            const currentPlaybackTime = audioContext.currentTime - startTime + startOffset;
            const newSeekTime = Math.min(processedBuffer.duration, currentPlaybackTime + 10); // Don't exceed duration
            startOffset = newSeekTime; // Update startOffset
            playProcessedAudio(); // This will stop current and start new from new startOffset
            showMessage(`Avanzando a ${formatTime(newSeekTime)}`, 'info');
        });


        volumeRange.addEventListener('input', () => {
            if (gainNode) {
                gainNode.gain.value = parseFloat(volumeRange.value);
                if (volumeRange.value == 0) {
                    volumeIcon.innerHTML = volumeMuteIcon;
                } else if (volumeRange.value < 0.5) {
                    volumeIcon.innerHTML = volumeLowIcon;
                } else {
                    volumeIcon.innerHTML = volumeHighIcon;
                }
            }
        });

        progressBarContainer.addEventListener('click', (e) => {
            if (!processedBuffer) return;

            const clickX = e.clientX - progressBarContainer.getBoundingClientRect().left;
            const percentage = clickX / progressBarContainer.offsetWidth;
            const seekTime = percentage * processedBuffer.duration;

            startOffset = seekTime; // Update startOffset
            playProcessedAudio(); // This will stop current and start new from new startOffset
        });

        // --- Download and Start Over Buttons ---
        downloadButton.addEventListener('click', () => {
            if (!processedBuffer) {
                showMessage('No hay audio procesado para descargar. Por favor, procesa el audio primero.', 'error');
                return;
            }

            stopPlayback(); // Stop any ongoing playback before download

            showMessage('Preparando descarga...', 'info');

            const wavData = encodeWAV(processedBuffer);
            const blob = new Blob([wavData], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'audio_procesado.wav'; // Suggests a filename
            document.body.appendChild(a);
            a.click(); // Programmatically click the link
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // Clean up

            // Inform the user about potential WebView limitations
            showMessage('La descarga deber√≠a comenzar. Si no, es posible que tu aplicaci√≥n no permita descargas directas. Intenta abrir la aplicaci√≥n en un navegador web (como Chrome o Chrome) en tu tel√©fono y descargar desde all√≠.', 'info');
        });

        // Download ZIP Button (for batch processing) - MODIFIED FOR APPCREATOR24 COMPATIBILITY
        downloadZipButton.addEventListener('click', () => {
            if (!finalProcessedZipBlob) {
                showMessage('No hay un archivo ZIP procesado para descargar.', 'error');
                return;
            }

            showMessage('Iniciando descarga del ZIP...', 'info');
            const zipUrl = URL.createObjectURL(finalProcessedZipBlob);
            
            const a = document.createElement('a');
            a.href = zipUrl;
            a.download = 'audios_procesados.zip'; // Suggests a filename
            document.body.appendChild(a);
            a.click(); // Programmatically click the link
            document.body.removeChild(a);
            URL.revokeObjectURL(zipUrl); // Clean up

            // Inform the user about potential WebView limitations
            showMessage('La descarga del ZIP deber√≠a comenzar. Si no, es posible que tu aplicaci√≥n no permita descargas directas. Intenta abrir la aplicaci√≥n en un navegador web (como Chrome o Chrome) en tu tel√©fono y descargar desde all√≠.', 'info');
        });


        startOverButton.addEventListener('click', () => {
            resetUI();
            showMessage('Aplicaci√≥n reiniciada. Sube un nuevo archivo.', 'info');
        });

        cancelProcessingButton.addEventListener('click', () => {
            processingAborted = true; // Set flag to abort processing
            showMessage('Cancelando procesamiento...', 'info');
        });

        cancelBatchButton.addEventListener('click', () => {
            batchProcessingAborted = true; // Set flag to abort batch processing
            showMessage('Cancelando procesamiento por lotes...', 'info');
        });


        // Helper function to encode AudioBuffer to WAV format
        function encodeWAV(audioBuffer) {
            const numChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const format = 1; // PCM (uncompressed)
            const bitDepth = 16; // 16-bit samples

            let interleaved = [];
            for (let i = 0; i < audioBuffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    interleaved.push(audioBuffer.getChannelData(channel)[i]);
                }
            }

            const buffer = new ArrayBuffer(44 + interleaved.length * 2);
            const view = new DataView(buffer);

            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + interleaved.length * 2, true); // ChunkSize
            writeString(view, 8, 'WAVE');

            // FMT sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)
            view.setUint16(20, format, true); // AudioFormat (1 for PCM)
            view.setUint16(22, numChannels, true); // NumChannels
            view.setUint32(24, sampleRate, true); // SampleRate
            view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true); // ByteRate
            view.setUint16(32, numChannels * (bitDepth / 8), true); // BlockAlign
            view.setUint16(34, bitDepth, true); // BitsPerSample

            // DATA sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, interleaved.length * 2, true); // Subchunk2Size

            // Write the PCM data
            let offset = 44;
            for (let i = 0; i < interleaved.length; i++, offset += 2) {
                let s = Math.max(-1, Math.min(1, interleaved[i])); // Clamp to -1 to 1
                s = s < 0 ? s * 0x8000 : s * 0x7FFF; // Convert to 16-bit integer
                view.setInt16(offset, s, true);
            }

            return buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // --- Initial Setup ---
        // Ensure AudioContext is resumed on first user gesture
        document.body.addEventListener('click', () => {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }, { once: true });

        // Adjust canvas size to be responsive
        function resizeCanvas() {
            // Set canvas dimensions to be square and fill available width up to max-w-xs
            const size = Math.min(circularSpectrumVisualizer.parentElement.offsetWidth, 200); // max-w-xs is 20rem = 320px, but h-32 is 128px, so limit by height
            circularSpectrumVisualizer.width = size;
            circularSpectrumVisualizer.height = size;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initial call

        // Tab button event listeners
        inicioTabButton.addEventListener('click', () => showSection('inicio'));
        advancedTabButton.addEventListener('click', () => showSection('advanced'));

        resetUI(); // Set initial UI state
    </script>
</body>
</html>

