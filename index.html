<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Slowed + Reverb</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- JSZip Library for ZIP handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip-utils/0.1.0/jszip-utils.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #1f2937;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 600px;
            padding: 1.5rem;
            border: 1px solid #374151;
            /* Flexbox for vertical stacking within the container */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        @media (min-width: 640px) {
            .container {
                padding: 2rem;
            }
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.3);
            margin-top: -9px;
        }
        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            cursor: pointer;
            background: #4b5563;
            border-radius: 3px;
        }
        .effects-group {
            width: 100%;
            display: flex; /* Use flex for internal spacing */
            flex-direction: column;
            gap: 1.5rem; /* Consistent spacing between effect controls */
            margin-top: 1.5rem; /* Adjusted top margin */
            padding-top: 1.5rem; /* Adjusted top padding */
            border-top: 1px solid #374151;
        }
        .music-player {
            background-color: #111827;
            border-radius: 1rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
            width: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .music-player.active {
            display: flex;
        }
        .progress-bar-container {
            width: 100%;
            height: 8px;
            background-color: #4b5563;
            border-radius: 4px;
            cursor: pointer;
        }
        .progress-bar {
            height: 100%;
            background-color: #3b82f6;
            border-radius: 4px;
            width: 0%;
        }
        .player-controls button {
            background: none;
            border: none;
            color: #e5e7eb;
            font-size: 1.8rem;
            cursor: pointer;
            padding: 0.5rem;
        }
        .tab-button {
            padding: 0.75rem 1rem;
            background-color: #374151;
            color: #e5e7eb;
            border: none;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            margin: 0 0.25rem;
            flex-grow: 1; /* Allow buttons to grow */
            max-width: 50%; /* Limit button width */
            text-align: center;
        }
        .tab-button.active {
            background-color: #3b82f6;
            color: #ffffff;
        }
        .processing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .processing-overlay.active {
            display: flex;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1.5rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Ensure canvas is responsive */
        #circularSpectrumVisualizer {
            display: block; /* Remove extra space below canvas */
            width: 100%; /* Make canvas fill its parent width */
            max-width: 200px; /* Limit max width for visualizer */
            height: 200px; /* Fixed height for circular visualizer */
        }
        @media (min-width: 640px) {
            #circularSpectrumVisualizer {
                max-width: 250px; /* Slightly larger on desktop */
                height: 250px;
            }
        }
    </style>
</head>
<body class="selection:bg-blue-500 selection:text-white">
    <div class="container" id="mainAppContainer">
        <h1 class="text-2xl sm:text-3xl font-bold text-blue-400 text-center mb-6">Generador de Efectos de Audio</h1>

        <!-- Tab Navigation -->
        <div class="flex justify-center gap-2 mb-6 w-full">
            <button id="configTabButton" class="tab-button active">Un Archivo</button>
            <button id="advancedTabButton" class="tab-button">Varios Archivos (ZIP)</button>
        </div>

        <!-- Configuration Section (Single File) -->
        <div id="configSection" class="w-full flex flex-col items-center gap-6">
            <div class="w-full">
                <label for="audioFile" class="block text-md sm:text-lg font-medium text-gray-300 mb-2">1. Sube tu audio:</label>
                <input type="file" id="audioFile" accept="audio/*" class="w-full p-3 border border-gray-600 rounded-lg bg-gray-700 text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 cursor-pointer text-sm">
                <p id="fileName" class="text-xs sm:text-sm text-gray-400 mt-2 text-center"></p>
            </div>

            <!-- Effects Group for Single File -->
            <div class="effects-group">
                <p class="text-lg sm:text-xl font-semibold text-gray-300 text-center">2. Ajusta los efectos</p>
                <div>
                    <label for="speedRange1" class="block text-md font-medium text-gray-300 mb-2">Slowed (Velocidad):</label>
                    <input type="range" id="speedRange1" min="0.5" max="1.5" value="0.85" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <p class="text-center text-gray-400 mt-2">Valor: <span id="speedValue1">0.85x</span></p>
                </div>
                <div>
                    <label for="reverbRange1" class="block text-md font-medium text-gray-300 mb-2">Reverb:</label>
                    <input type="range" id="reverbRange1" min="0" max="1" value="0.5" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <p class="text-center text-gray-400 mt-2">Valor: <span id="reverbValue1">0.50</span></p>
                </div>
            </div>

            <div class="w-full flex justify-center mt-6">
                <button id="processButton" class="px-6 py-3 sm:px-8 sm:py-4 bg-blue-600 text-white font-semibold rounded-full shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition-all duration-200 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    Procesar Audio
                </button>
            </div>
        </div>

        <!-- Advanced Section (ZIP Batch) -->
        <div id="advancedSection" class="w-full flex-col items-center gap-6" style="display: none;">
            <!-- Effects Group for Batch -->
             <div class="effects-group">
                <p class="text-lg sm:text-xl font-semibold text-gray-300 text-center">1. Ajusta los efectos para todos los archivos</p>
                <div>
                    <label for="speedRange2" class="block text-md font-medium text-gray-300 mb-2">Slowed (Velocidad):</label>
                    <input type="range" id="speedRange2" min="0.5" max="1.5" value="0.85" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <p class="text-center text-gray-400 mt-2">Valor: <span id="speedValue2">0.85x</span></p>
                </div>
                <div>
                    <label for="reverbRange2" class="block text-md font-medium text-gray-300 mb-2">Reverb:</label>
                    <input type="range" id="reverbRange2" min="0" max="1" value="0.5" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <p class="text-center text-gray-400 mt-2">Valor: <span id="reverbValue2">0.50</span></p>
                </div>
            </div>

            <div class="w-full border-t border-gray-700 pt-6 mt-6">
                <label for="zipFile" class="block text-md sm:text-lg font-medium text-gray-300 mb-2">2. Sube tu archivo .zip:</label>
                <input type="file" id="zipFile" accept=".zip" class="w-full p-3 border border-gray-600 rounded-lg bg-gray-700 text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 cursor-pointer text-sm">
                <p id="zipFileName" class="text-xs sm:text-sm text-gray-400 mt-2 text-center"></p>
            </div>

            <div class="w-full flex justify-center mt-6">
                <button id="processZipButton" class="px-6 py-3 sm:px-8 sm:py-4 bg-purple-600 text-white font-semibold rounded-full shadow-lg hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75 transition-all duration-200 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    Procesar ZIP
                </button>
            </div>

            <div id="batchResultSection" class="w-full flex flex-col items-center gap-4 mt-6" style="display: none;">
                <p id="batchResultMessage" class="text-lg font-semibold text-green-400"></p>
                <div id="failedFilesList" class="w-full text-sm text-gray-400 mt-2 p-2 bg-gray-800 rounded-lg" style="display: none;">
                    <p class="font-semibold text-red-400">Archivos que fallaron:</p>
                    <ul id="failedFilesUl" class="mt-1 list-disc list-inside"></ul>
                </div>
                <button id="downloadZipButton" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-full shadow-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75">
                    Descargar ZIP
                </button>
            </div>
        </div>

        <!-- Music Player Section -->
        <div class="music-player" id="musicPlayerSection">
            <p class="text-lg sm:text-xl font-semibold text-gray-300 mb-4 text-center">¡Disfruta tu canción!</p>
            <div class="w-full mb-4 flex justify-center items-center">
                <canvas id="circularSpectrumVisualizer"></canvas>
            </div>
            <div class="w-full mb-4">
                <div class="flex justify-between text-xs text-gray-400 mb-1">
                    <span id="currentTime">00:00</span>
                    <span id="totalDuration">00:00</span>
                </div>
                <div class="progress-bar-container" id="progressBarContainer">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
            </div>
            <div class="player-controls w-full flex items-center justify-around mb-4">
                <button id="loopButton" title="Bucle"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 1l4 4-4 4"/><path d="M3 11v-1a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v1a4 4 0 0 1-4 4H3"/></svg></button>
                <button id="playPauseButton" title="Reproducir/Pausar" class="text-3xl"></button>
                <div class="flex items-center space-x-2">
                    <button id="volumeIcon" title="Volumen"></button>
                    <input type="range" id="volumeRange" min="0" max="1" value="1" step="0.01" class="w-20">
                </div>
            </div>
            <div class="w-full flex flex-col sm:flex-row justify-center items-center gap-3 sm:gap-4 mt-4">
                <button id="downloadButton" class="w-full sm:w-auto px-6 py-3 bg-green-600 text-white font-semibold rounded-full shadow-lg hover:bg-green-700">Descargar</button>
                <button id="startOverButton" class="w-full sm:w-auto px-6 py-3 bg-gray-600 text-white font-semibold rounded-full shadow-lg hover:bg-gray-700">Empezar de Nuevo</button>
            </div>
        </div>

        <div id="messageBox" class="w-full p-3 mt-4 text-center rounded-lg hidden text-sm">
            <p id="messageText"></p>
        </div>
    </div>

    <!-- Processing Overlays -->
    <div class="processing-overlay" id="processingOverlay">
        <div class="bg-gray-800 rounded-xl p-8 text-center shadow-lg">
            <h2 class="text-xl font-bold text-blue-400 mb-4">Procesando...</h2>
            <div class="spinner"></div>
            <p class="text-gray-300 mt-4 text-sm">Esto puede tardar un momento.</p>
        </div>
    </div>
    <div class="processing-overlay" id="batchStatusOverlay">
         <div class="bg-gray-800 rounded-xl p-8 text-center shadow-lg w-11/12 max-w-sm">
            <h2 class="text-xl font-bold text-blue-400 mb-4">Procesando Lote</h2>
            <div class="spinner"></div>
            <p class="text-gray-300 mt-4 text-sm" id="batchProgressText">Iniciando...</p>
            <p class="text-gray-400 mt-1 text-xs break-all" id="batchCurrentFileName"></p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const elements = {
                configTab: document.getElementById('configTabButton'),
                advancedTab: document.getElementById('advancedTabButton'),
                configSection: document.getElementById('configSection'),
                advancedSection: document.getElementById('advancedSection'),
                musicPlayer: document.getElementById('musicPlayerSection'),
                audioFile: document.getElementById('audioFile'),
                fileName: document.getElementById('fileName'),
                processButton: document.getElementById('processButton'),
                downloadButton: document.getElementById('downloadButton'),
                startOverButton: document.getElementById('startOverButton'),
                messageBox: document.getElementById('messageBox'),
                messageText: document.getElementById('messageText'),
                visualizer: document.getElementById('circularSpectrumVisualizer'),
                processingOverlay: document.getElementById('processingOverlay'),
                currentTime: document.getElementById('currentTime'),
                totalDuration: document.getElementById('totalDuration'),
                progressBarContainer: document.getElementById('progressBarContainer'),
                progressBar: document.getElementById('progressBar'),
                loopButton: document.getElementById('loopButton'),
                playPauseButton: document.getElementById('playPauseButton'),
                volumeIcon: document.getElementById('volumeIcon'),
                volumeRange: document.getElementById('volumeRange'),
                zipFile: document.getElementById('zipFile'),
                zipFileName: document.getElementById('zipFileName'),
                processZipButton: document.getElementById('processZipButton'),
                batchResultSection: document.getElementById('batchResultSection'),
                batchResultMessage: document.getElementById('batchResultMessage'),
                failedFilesList: document.getElementById('failedFilesList'),
                failedFilesUl: document.getElementById('failedFilesUl'),
                downloadZipButton: document.getElementById('downloadZipButton'),
                batchStatusOverlay: document.getElementById('batchStatusOverlay'),
                batchProgressText: document.getElementById('batchProgressText'),
                batchCurrentFileName: document.getElementById('batchCurrentFileName'),
                // Effect controls
                speedRange1: document.getElementById('speedRange1'),
                speedValue1: document.getElementById('speedValue1'),
                reverbRange1: document.getElementById('reverbRange1'),
                reverbValue1: document.getElementById('reverbValue1'),
                speedRange2: document.getElementById('speedRange2'),
                speedValue2: document.getElementById('speedValue2'),
                reverbRange2: document.getElementById('reverbRange2'),
                reverbValue2: document.getElementById('reverbValue2'),
            };

            const canvasCtx = elements.visualizer.getContext('2d');

            // --- Player Icons ---
            const icons = {
                play: '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="currentColor"><polygon points="6 3 20 12 6 21 6 3"/></svg>',
                pause: '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="currentColor"><rect x="5" y="3" width="4" height="18" rx="1"/><rect x="15" y="3" width="4" height="18" rx="1"/></svg>',
                volumeHigh: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>',
                volumeLow: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>',
                volumeMute: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="22" x2="16" y1="9" y2="15"/><line x1="16" x2="22" y1="9" y2="15"/></svg>',
            };

            // --- State ---
            let audioContext;
            let originalBuffer = null, processedBuffer = null, finalZipBlob = null;
            let currentSource = null, analyserNode = null, gainNode = null;
            let animationFrameId = null;
            let isPlaying = false, isLooping = false;
            let startOffset = 0, startTime = 0;
            
            // --- Utility Functions ---
            function formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            // --- UI State & Logic ---
            function showSection(sectionId) {
                elements.configSection.style.display = 'none';
                elements.advancedSection.style.display = 'none';
                elements.configTab.classList.remove('active');
                elements.advancedTab.classList.remove('active');
                if (sectionId === 'config') {
                    elements.configSection.style.display = 'flex';
                    elements.configTab.classList.add('active');
                } else {
                    elements.advancedSection.style.display = 'flex';
                    elements.advancedTab.classList.add('active');
                }
            }
            
            function showMessage(text, type = 'info') {
                elements.messageText.textContent = text;
                elements.messageBox.className = 'w-full p-3 mt-4 text-center rounded-lg text-sm';
                const typeClasses = {
                    error: 'bg-red-800 text-red-200',
                    success: 'bg-green-800 text-green-200',
                    info: 'bg-yellow-800 text-yellow-200'
                };
                elements.messageBox.classList.add(...(typeClasses[type] || typeClasses.info).split(' '));
                elements.messageBox.classList.remove('hidden');
            }

            function hideMessage() {
                elements.messageBox.classList.add('hidden');
            }

            function resetUI() {
                stopPlayback();
                originalBuffer = null;
                processedBuffer = null;
                finalZipBlob = null;
                elements.audioFile.value = '';
                elements.zipFile.value = '';
                elements.fileName.textContent = '';
                elements.zipFileName.textContent = '';
                elements.processButton.disabled = true;
                elements.processZipButton.disabled = true;
                elements.batchResultSection.style.display = 'none';
                elements.musicPlayer.classList.remove('active');
                hideMessage();
                showSection('config');
                elements.playPauseButton.innerHTML = icons.play;
                elements.progressBar.style.width = '0%';
                elements.currentTime.textContent = '00:00';
                elements.totalDuration.textContent = '00:00';
                isLooping = false;
                elements.loopButton.classList.remove('text-blue-400');
                // Reset visualizer
                canvasCtx.clearRect(0, 0, elements.visualizer.width, elements.visualizer.height);
            }

            // --- Effect Controls Syncing ---
            function syncControls(sourceElement) {
                const speed = sourceElement.id.includes('speed') ? sourceElement.value : elements.speedRange1.value;
                const reverb = sourceElement.id.includes('reverb') ? sourceElement.value : elements.reverbRange1.value;

                elements.speedRange1.value = elements.speedRange2.value = speed;
                elements.speedValue1.textContent = elements.speedValue2.textContent = `${parseFloat(speed).toFixed(2)}x`;

                elements.reverbRange1.value = elements.reverbRange2.value = reverb;
                elements.reverbValue1.textContent = elements.reverbValue2.textContent = parseFloat(reverb).toFixed(2);
            }

            ['speedRange1', 'reverbRange1', 'speedRange2', 'reverbRange2'].forEach(id => {
                document.getElementById(id).addEventListener('input', (e) => syncControls(e.target));
            });

            // --- Audio Context ---
            function initAudioContext() {
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        analyserNode = audioContext.createAnalyser();
                        analyserNode.fftSize = 256; // Smaller FFT size for faster visualization
                        gainNode = audioContext.createGain(); // For volume control
                        // Connect gainNode to analyser and then to destination
                        gainNode.connect(analyserNode);
                        analyserNode.connect(audioContext.destination);
                    } catch (e) {
                        showMessage('Web Audio API no es compatible con este navegador.', 'error');
                        console.error("Error initializing AudioContext:", e);
                    }
                }
                // Resume context if suspended (e.g., after user interaction)
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().catch(e => console.error("Error resuming AudioContext:", e));
                }
            }

            // --- File Handling ---
            elements.audioFile.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                elements.fileName.textContent = file.name;
                showMessage('Cargando audio...', 'info');
                elements.processButton.disabled = true;
                stopPlayback(); // Stop any current playback
                initAudioContext(); // Initialize context on user interaction
                const arrayBuffer = await file.arrayBuffer();
                try {
                    originalBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    showMessage('Audio listo para procesar.', 'success');
                    elements.processButton.disabled = false;
                } catch (e) {
                    showMessage('Error al decodificar el audio. Asegúrate de que sea un archivo de audio válido (ej. MP3, WAV, M4A).', 'error');
                    console.error("Error decoding audio data:", e);
                    resetUI(); // Reset UI on error
                }
            });

            elements.zipFile.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    elements.zipFileName.textContent = file.name;
                    elements.processZipButton.disabled = false;
                    elements.batchResultSection.style.display = 'none';
                    showMessage('ZIP listo para procesar.', 'info');
                } else {
                    elements.zipFileName.textContent = '';
                    elements.processZipButton.disabled = true;
                }
            });

            // --- Core Audio Processing ---
            async function applyEffectsToBuffer(inputBuffer) {
                const settings = {
                    speed: parseFloat(elements.speedRange1.value),
                    reverb: parseFloat(elements.reverbRange1.value),
                };

                // Calculate the duration of the output buffer based on speed
                const outputDuration = inputBuffer.duration / settings.speed;
                // Use the same number of channels as the input buffer
                const offlineCtx = new OfflineAudioContext(inputBuffer.numberOfChannels, outputDuration * inputBuffer.sampleRate, inputBuffer.sampleRate);
                
                const source = offlineCtx.createBufferSource();
                source.buffer = inputBuffer;
                source.playbackRate.value = settings.speed;

                let currentNode = source; // This will be the last node in our chain before destination

                // Reverb
                if (settings.reverb > 0) {
                    const convolver = offlineCtx.createConvolver();
                    // Generate a simple impulse response for reverb
                    const impulseDuration = 2; // seconds
                    const decay = 2; // decay factor
                    const impulse = offlineCtx.createBuffer(2, offlineCtx.sampleRate * impulseDuration, offlineCtx.sampleRate);
                    for (let i = 0; i < 2; i++) {
                        const channel = impulse.getChannelData(i);
                        for (let j = 0; j < impulse.length; j++) {
                            // Generate a decaying random noise for impulse response
                            channel[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / impulse.length, decay);
                        }
                    }
                    convolver.buffer = impulse;

                    const wetGain = offlineCtx.createGain();
                    wetGain.gain.value = settings.reverb; // How much reverb
                    const dryGain = offlineCtx.createGain();
                    dryGain.gain.value = 1 - settings.reverb; // How much original signal

                    // Connect source to dry path
                    source.connect(dryGain);
                    // Connect source to wet (convolver) path
                    source.connect(convolver).connect(wetGain);

                    // Create a merger to combine dry and wet signals
                    const merger = offlineCtx.createChannelMerger(inputBuffer.numberOfChannels);
                    
                    // Connect dry and wet signals to the merger
                    // Assuming stereo output for simplicity if input is stereo, otherwise mono.
                    dryGain.connect(merger, 0, 0); 
                    wetGain.connect(merger, 0, 0); 
                    if (inputBuffer.numberOfChannels > 1) {
                         dryGain.connect(merger, 0, 1);
                         wetGain.connect(merger, 0, 1);
                    }

                    currentNode = merger; // The output of reverb is now the current node
                }

                // Connect the final node in the chain to the offline context's destination
                currentNode.connect(offlineCtx.destination);

                source.start(0);

                try {
                    console.log("Attempting to render offline audio context...");
                    const processedAudioBuffer = await offlineCtx.startRendering();
                    console.log("Offline rendering successful. Processed buffer duration:", processedAudioBuffer.duration);
                    if (processedAudioBuffer.duration === 0) {
                        console.warn("Rendered buffer has zero duration. This might indicate an issue with the audio graph or input.");
                    }
                    return processedAudioBuffer;
                } catch (renderingError) {
                    console.error("Error during offline audio rendering:", renderingError);
                    // Return a tiny, silent buffer to indicate failure gracefully
                    return offlineCtx.createBuffer(inputBuffer.numberOfChannels, 1, inputBuffer.sampleRate); 
                }
            }

            // --- Playback ---
            function playProcessedAudio() {
                if (!processedBuffer) return;
                stopPlayback(); // Ensure any previous playback is stopped
                initAudioContext(); // Ensure context is active

                currentSource = audioContext.createBufferSource();
                currentSource.buffer = processedBuffer;
                currentSource.connect(gainNode); // Connect to gain node for volume control
                currentSource.loop = isLooping;

                // Calculate where to resume playback
                const resumeTime = startOffset % processedBuffer.duration;
                startTime = audioContext.currentTime - resumeTime; // Store the actual start time

                currentSource.start(0, resumeTime); // Start from resumeTime
                isPlaying = true;
                elements.playPauseButton.innerHTML = icons.pause;
                updateProgressBar(); // Start updating progress bar
                drawVisualizer(); // Start drawing visualizer

                currentSource.onended = () => {
                    if (isPlaying && !isLooping) {
                        resetPlayback(); // Reset if not looping and playback ends
                    } else if (isPlaying && isLooping) {
                        // If looping, the source will automatically restart, but we might want to reset UI progress
                        startOffset = 0; // Reset offset for visualizer/progress bar
                        startTime = audioContext.currentTime; // Reset start time for visualizer/progress bar
                    }
                };
            }
            
            function stopPlayback() {
                if (currentSource) {
                    currentSource.onended = null; // Remove onended listener to prevent unwanted resets
                    currentSource.stop();
                    currentSource = null;
                }
                isPlaying = false;
                elements.playPauseButton.innerHTML = icons.play;
                cancelAnimationFrame(animationFrameId); // Stop visualizer animation
            }

            function resetPlayback() {
                stopPlayback();
                startOffset = 0; // Reset playback position
                elements.progressBar.style.width = '0%';
                elements.currentTime.textContent = '00:00';
            }

            function updateProgressBar() {
                if (!isPlaying || !processedBuffer) return;

                const elapsed = audioContext.currentTime - startTime;
                startOffset = elapsed; // Update startOffset for pausing/resuming
                const progress = (elapsed / processedBuffer.duration) * 100;
                elements.progressBar.style.width = `${progress}%`;
                elements.currentTime.textContent = formatTime(elapsed);

                if (elapsed >= processedBuffer.duration && !isLooping) {
                    resetPlayback(); // Ensure full reset if not looping
                } else {
                    requestAnimationFrame(updateProgressBar);
                }
            }

            function drawVisualizer() {
                if (!isPlaying) {
                    canvasCtx.clearRect(0, 0, elements.visualizer.width, elements.visualizer.height);
                    return;
                }
                animationFrameId = requestAnimationFrame(drawVisualizer);

                const bufferLength = analyserNode.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyserNode.getByteFrequencyData(dataArray);

                canvasCtx.clearRect(0, 0, elements.visualizer.width, elements.visualizer.height);

                const centerX = elements.visualizer.width / 2;
                const centerY = elements.visualizer.height / 2;
                const baseRadius = Math.min(centerX, centerY) / 4; // Base radius for the circle
                const barWidth = 2; // Width of each bar
                const maxBarHeight = baseRadius * 1.5; // Max height for the bars

                canvasCtx.fillStyle = '#3b82f6'; // Color for the bars

                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * maxBarHeight; // Scale height based on frequency data
                    const angle = (i / bufferLength) * Math.PI * 2; // Full circle

                    const x = centerX + Math.cos(angle) * (baseRadius + barHeight / 2);
                    const y = centerY + Math.sin(angle) * (baseRadius + barHeight / 2);

                    canvasCtx.save();
                    canvasCtx.translate(centerX, centerY);
                    canvasCtx.rotate(angle);
                    canvasCtx.fillRect(baseRadius, -barWidth / 2, barHeight, barWidth);
                    canvasCtx.restore();
                }
            }

            // --- Event Listeners ---
            elements.processButton.addEventListener('click', async () => {
                if (!originalBuffer) {
                    showMessage('Por favor, sube un archivo de audio primero.', 'error');
                    return;
                }
                elements.processingOverlay.classList.add('active');
                hideMessage(); // Hide previous messages
                try {
                    processedBuffer = await applyEffectsToBuffer(originalBuffer);
                    elements.musicPlayer.classList.add('active');
                    elements.totalDuration.textContent = formatTime(processedBuffer.duration);
                    playProcessedAudio();
                    showMessage('Audio procesado con éxito. ¡Listo para escuchar!', 'success');
                } catch (e) {
                    showMessage('Error al procesar el audio. Intenta con otro archivo o ajusta los efectos.', 'error');
                    console.error("Error during audio processing:", e);
                } finally {
                    elements.processingOverlay.classList.remove('active');
                }
            });

            elements.processZipButton.addEventListener('click', async () => {
                const file = elements.zipFile.files[0];
                if (!file) {
                    showMessage('Por favor, sube un archivo ZIP primero.', 'error');
                    return;
                }
                elements.batchStatusOverlay.classList.add('active');
                elements.batchProgressText.textContent = 'Iniciando...';
                elements.batchCurrentFileName.textContent = '';
                elements.batchResultSection.style.display = 'none';

                const outputZip = new JSZip();
                const failedFiles = [];
                let filesProcessedSuccessfully = 0;
                let totalFiles = 0;

                try {
                    const zip = await JSZip.loadAsync(file);
                    const audioFiles = Object.values(zip.files).filter(f => !f.dir && /\.(mp3|wav|ogg|flac|m4a)$/i.test(f.name));
                    
                    if (audioFiles.length === 0) {
                        showMessage('El archivo ZIP no contiene archivos de audio válidos (MP3, WAV, OGG, FLAC, M4A).', 'error');
                        elements.batchStatusOverlay.classList.remove('active');
                        return;
                    }

                    totalFiles = audioFiles.length;
                    let count = 0;
                    for (const audioFile of audioFiles) {
                        count++;
                        elements.batchProgressText.textContent = `Procesando ${count} de ${totalFiles}`;
                        elements.batchCurrentFileName.textContent = audioFile.name;
                        
                        initAudioContext(); 
                        const buffer = await audioFile.async('arraybuffer');
                        
                        try {
                            const decoded = await audioContext.decodeAudioData(buffer);
                            const processed = await applyEffectsToBuffer(decoded);

                            if (processed.duration > 0) {
                                const wav = encodeWAV(processed);
                                outputZip.file(audioFile.name.replace(/\.[^/.]+$/, "") + '_processed.wav', wav);
                                filesProcessedSuccessfully++;
                            } else {
                                failedFiles.push(audioFile.name);
                                console.warn(`[Batch] Procesamiento de ${audioFile.name} falló (duración cero).`);
                            }
                        } catch (fileError) {
                            failedFiles.push(audioFile.name);
                            console.warn(`[Batch] Fallo al decodificar o procesar ${audioFile.name}:`, fileError);
                        }
                    }

                    elements.batchResultSection.style.display = 'flex';
                    if (filesProcessedSuccessfully > 0) {
                        finalZipBlob = await outputZip.generateAsync({ type: 'blob' });
                        elements.downloadZipButton.style.display = 'block';
                        elements.batchResultMessage.textContent = `Procesamiento de lote completado. ${filesProcessedSuccessfully} de ${totalFiles} archivos procesados con éxito.`;
                        elements.batchResultMessage.className = 'text-lg font-semibold text-green-400';
                        showMessage('Lote completado con éxito.', 'success');
                    } else {
                        elements.downloadZipButton.style.display = 'none';
                        elements.batchResultMessage.textContent = 'Procesamiento de lote completado, pero no se pudo procesar ningún archivo de audio.';
                        elements.batchResultMessage.className = 'text-lg font-semibold text-red-400';
                        showMessage('Todos los archivos fallaron. Asegúrate de que sean formatos de audio válidos.', 'error');
                    }
                    
                    if (failedFiles.length > 0) {
                        elements.failedFilesList.style.display = 'block';
                        elements.failedFilesUl.innerHTML = '';
                        failedFiles.forEach(fileName => {
                            const li = document.createElement('li');
                            li.textContent = fileName;
                            elements.failedFilesUl.appendChild(li);
                        });
                    } else {
                         elements.failedFilesList.style.display = 'none';
                    }

                } catch (e) {
                    showMessage('Error procesando el archivo ZIP. Asegúrate de que sea un ZIP válido y contenga archivos de audio.', 'error');
                    console.error("Error processing ZIP file:", e);
                } finally {
                    elements.batchStatusOverlay.classList.remove('active');
                }
            });
            
            elements.playPauseButton.addEventListener('click', () => {
                if (!processedBuffer) {
                    showMessage('Sube y procesa un audio para reproducirlo.', 'info');
                    return;
                }
                initAudioContext(); // Ensure context is ready
                if (isPlaying) {
                    startOffset = audioContext.currentTime - startTime; // Save current position
                    stopPlayback();
                } else {
                    playProcessedAudio();
                }
            });

            elements.downloadButton.addEventListener('click', () => {
                if (!processedBuffer) {
                    showMessage('No hay audio procesado para descargar.', 'info');
                    return;
                }
                try {
                    const wav = encodeWAV(processedBuffer);
                    const blob = new Blob([wav], { type: 'audio/wav' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'audio_procesado.wav';
                    document.body.appendChild(a); // Append to body to make it clickable
                    a.click();
                    document.body.removeChild(a); // Clean up
                    URL.revokeObjectURL(url);
                    showMessage('Audio descargado con éxito.', 'success');
                } catch (e) {
                    showMessage('Error al descargar el audio. Inténtalo de nuevo.', 'error');
                    console.error("Error downloading audio:", e);
                }
            });

            elements.downloadZipButton.addEventListener('click', () => {
                if (!finalZipBlob) {
                    showMessage('No hay ZIP procesado para descargar.', 'info');
                    return;
                }
                try {
                    const url = URL.createObjectURL(finalZipBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'audios_procesados.zip';
                    document.body.appendChild(a); // Append to body to make it clickable
                    a.click();
                    document.body.removeChild(a); // Clean up
                    URL.revokeObjectURL(url);
                    showMessage('ZIP descargado con éxito.', 'success');
                } catch (e) {
                    showMessage('Error al descargar el ZIP. Inténtalo de nuevo.', 'error');
                    console.error("Error downloading ZIP:", e);
                }
            });

            elements.startOverButton.addEventListener('click', resetUI);
            elements.configTab.addEventListener('click', () => showSection('config'));
            elements.advancedTab.addEventListener('click', () => showSection('advanced'));
            
            elements.loopButton.addEventListener('click', () => {
                isLooping = !isLooping;
                elements.loopButton.classList.toggle('text-blue-400', isLooping);
                if (currentSource) {
                    currentSource.loop = isLooping;
                }
                showMessage(isLooping ? 'Bucle activado.' : 'Bucle desactivado.', 'info');
            });

            elements.volumeRange.addEventListener('input', () => {
                if (gainNode) {
                    gainNode.gain.value = elements.volumeRange.value;
                    if (elements.volumeRange.value == 0) {
                        elements.volumeIcon.innerHTML = icons.volumeMute;
                    } else if (elements.volumeRange.value < 0.5) {
                        elements.volumeIcon.innerHTML = icons.volumeLow;
                    } else {
                        elements.volumeIcon.innerHTML = icons.volumeHigh;
                    }
                }
            });

            // Handle progress bar click to seek
            elements.progressBarContainer.addEventListener('click', (e) => {
                if (!processedBuffer) return;
                const rect = elements.progressBarContainer.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percentage = clickX / rect.width;
                const seekTime = processedBuffer.duration * percentage;

                stopPlayback();
                startOffset = seekTime;
                playProcessedAudio();
            });

            // --- Canvas Resizing for Responsiveness ---
            function resizeCanvas() {
                const parent = elements.visualizer.parentElement;
                if (parent) {
                    // Set canvas dimensions to match its parent's client dimensions
                    elements.visualizer.width = parent.clientWidth;
                    elements.visualizer.height = parent.clientHeight;
                }
                // Redraw visualizer if playing to adapt to new size
                if (isPlaying) {
                    drawVisualizer();
                }
            }

            // Initial resize and add listener for window resize
            window.addEventListener('resize', resizeCanvas);


            // --- Init ---
            function init() {
                resetUI();
                elements.playPauseButton.innerHTML = icons.play;
                elements.volumeIcon.innerHTML = icons.volumeHigh;
                elements.volumeRange.value = 1; // Set initial volume
                syncControls(elements.speedRange1); // Initial sync of controls
                resizeCanvas(); // Initial canvas resize
            }
            init();

            // --- WAV Encoder (COMPLETE) ---
            function encodeWAV(audioBuffer) {
                const numOfChan = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const bytesPerSample = 2; // 16-bit PCM
                const blockAlign = numOfChan * bytesPerSample;
                
                // Calculate total length of data (all channels combined)
                const dataLength = audioBuffer.getChannelData(0).length * numOfChan * bytesPerSample;
                const fileLength = 36 + dataLength; // 36 bytes for header + data length

                const buffer = new ArrayBuffer(44 + dataLength);
                const view = new DataView(buffer);
                let offset = 0;

                /* RIFF identifier */
                writeString(view, offset, 'RIFF'); offset += 4;
                /* file length */
                view.setUint32(offset, fileLength, true); offset += 4;
                /* RIFF type */
                writeString(view, offset, 'WAVE'); offset += 4;

                /* format chunk identifier */
                writeString(view, offset, 'fmt '); offset += 4;
                /* format chunk length */
                view.setUint32(offset, 16, true); offset += 4; // 16 for PCM
                /* sample format (1 for PCM) */
                view.setUint16(offset, 1, true); offset += 2; // PCM = 1
                /* number of channels */
                view.setUint16(offset, numOfChan, true); offset += 2;
                /* sample rate */
                view.setUint32(offset, sampleRate, true); offset += 4;
                /* byte rate (sample rate * block align) */
                view.setUint32(offset, sampleRate * blockAlign, true); offset += 4;
                /* block align (channels * bytes per sample) */
                view.setUint16(offset, blockAlign, true); offset += 2;
                /* bits per sample */
                view.setUint16(offset, 16, true); offset += 2; // 16-bit

                /* data chunk identifier */
                writeString(view, offset, 'data'); offset += 4;
                /* data chunk length */
                view.setUint32(offset, dataLength, true); offset += 4;

                // Write audio data
                floatTo16BitPCM(view, offset, audioBuffer);

                return buffer;
            }

            // Helper to write string to DataView
            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            // Helper to convert float32 AudioBuffer data to 16-bit PCM
            function floatTo16BitPCM(output, offset, inputBuffer) {
                const channels = [];
                for (let i = 0; i < inputBuffer.numberOfChannels; i++) {
                    channels.push(inputBuffer.getChannelData(i));
                }
                const numSamples = channels[0].length;
                const numChannels = channels.length;

                for (let i = 0; i < numSamples; i++) {
                    for (let channel = 0; channel < numChannels; channel++) {
                        let s = Math.max(-1, Math.min(1, channels[channel][i])); // Clamp to -1 to 1
                        s = s < 0 ? s * 0x8000 : s * 0x7FFF; // Convert float to 16-bit integer (signed)
                        output.setInt16(offset, s, true); // Write as little-endian
                        offset += 2;
                    }
                }
            }
        });
    </script>
</body>
</html>

